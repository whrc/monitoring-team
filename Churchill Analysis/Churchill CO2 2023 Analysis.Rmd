---
title: "Churchill CO2 Data Analysis"
author: "Dani Trangmoe"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# add root directory here for github
```

Notes:

```{r, include=FALSE}
rm(list = ls())

library(data.table)
library(ggplot2)
library(cowplot)
library(openair)
library(plotrix)
library(signal)
library(svMisc)
library(zoo)
library(stringr)
library(plyr)
library(viridis)
library(lubridate)
library(tidyverse)
library(gridExtra)
library(plotly)
library(RColorBrewer)
library(pracma)
```

# Load data

```{r}

df = fread('C:/Users/dtrangmoe/Documents/Churchill/Churchill_Merged_CF1_CF3.csv',na.strings = c('-9999','NA','NaN','NAN','-7999'))

#needs continuous day variable
df_avg = fread('C:/Users/dtrangmoe/Documents/Churchill/Churchill_Merged_Avg_CF1_CF3.csv',na.strings = c('-9999','NA','NaN','NAN','-7999'))


```

#### Create yearly dataframes, timestamp

```{r}
#create TIMESTAMP variable that is = to TIMESTAMP_END

df$TIMESTAMP = df$TIMESTAMP_END

year_df <- function(df, year) {
  df %>%
    filter(format(day, "%Y") == as.character(year)) %>%
    mutate(DOY = yday(day))
}


#Creates data frames of each year containing the daily averages of each value- useful for focusing on one year at a time

df_avg$day <- as.POSIXct(df_avg$day, format = "%Y-%m-%d")

df_avg_2022 <- year_df(df_avg, 2022)
df_avg_2023 <- year_df(df_avg, 2023)

df_2023 <- year_df(df, 2023)


```


# Nighttime CO2 data

Isolates nighttime CO2 Flux data in the half-hourly dataframe

```{r}

# # Visualize incoming shortwave Data
# ggplot(data=df_2023)+
#   geom_point(aes(x=TIMESTAMP, y=SW_IN))+
#   geom_hline(yintercept = 0)

# Filter CO2 Flux data by incoming shortwave values
df_2023 <- df_2023 %>%
  mutate(FC_night = ifelse(SW_IN <= 0, FC, NA))

# # Plot the filtered vs. unfiltered CO2 Flux values to visualize nighttime data
# ggplot(data = df_2023)+
#   geom_hline(yintercept = 0)+
#   geom_point(aes(TIMESTAMP,FC,col='Original'))+
#   geom_point(aes(TIMESTAMP,FC_night,col='Nighttime CO2 Flux'))+
#   scale_y_continuous(limits=c(-7,6))+
#   scale_x_datetime(limits = as.POSIXct(dates_23,format="%F"))+
#   labs(y = "CO2 Flux", x = "Time") +
#   scale_color_manual(values=c('deeppink3','black'))
```


### Date ranges for plots

Adjust dates here!

```{r}

dates_23 = c('2023-01-01','2023-12-01')

snowmelt23 = c('2023-04-23','2023-05-15')
```

### [Plot 1] GPP & ER Plots

```{r}

ggplot(data = df_avg_2023, aes(x=day))+
  theme_bw()+
  geom_point(aes(y = -GPP_F*60*60*24*(1/1000000)*12, color = "GPP"))+
  geom_point(aes(y = RECO*60*60*24*(1/1000000)*12, color = "Respiration")) +
  geom_line(aes(y = FC_F*60*60*24*(1/1000000)*12, color = "NEE"))+
  geom_line(aes(y = FCH4_F*60*60*24*(1/1000000)*12*13, color = "CH4"))+
  geom_hline(yintercept=0, col="black")+
  scale_y_continuous(expression('CO'[2]*' Flux (g C'~m^-2~d^-1*')'),
  sec.axis = sec_axis(~ . * 13, name = expression('CH'[4]*' Flux (g C'~m^-2~d^-1*')')))+
  scale_color_manual(name = " ",
            values = c("GPP" = "navy", 
                      "Respiration" = "turquoise3", 
                      "NEE" = "salmon", 
                      "CH4" = "mediumorchid"),
            breaks = c("GPP", "Respiration", "NEE", "CH4"))
  # +labs(title = expression('Partitioned CO'[2]*' Data 2023'))

```



#### Gap Filling Plot

Shows gap in flux data and compares gap filled and non-gap filled data

```{r}

#Uses Half-Hourly data

ggplot(data = df_2023)+
  geom_hline(yintercept = 0)+
  geom_point(aes(TIMESTAMP,FC_F,col='Gapfilled'))+
  geom_point(aes(TIMESTAMP,FC,col='Original'))+
  scale_y_continuous(limits=c(-7,6))+
  scale_x_datetime(limits = as.POSIXct(dates_23,format="%F"))+
  labs(y = "CO2 Flux ", x = "Time") +
  scale_color_manual(values=c('red','black'))+
  geom_vline(xintercept = as.POSIXct("2023-07-05"))


```


#### [Plot 2] Net C Budget

```{r}


#Creates numeric timestamp with the unit of minutes to integrate over half-hourly data

df_2023 <- df_2023 %>%
  mutate(time_minutes = as.numeric(difftime(TIMESTAMP, min(TIMESTAMP), units = "mins")))

# Units start as Micromoles of CO2/(m^2s), converted to Grams of C/m^2/minute, integrated over minutes to get Grams of C/m^2

# Net CO2 Flux
df_2023 <- df_2023 %>%
  mutate(FC_F_no_NAs = ifelse(is.na(FC_F), 0, FC_F * 60 * (1/1000000) * 12))

net_CO2 <- trapz(df_2023$time_minutes, df_2023$FC_F_no_NAs)

# Units start as micromoles of CH4/(m^2s), converted to Grams of C/m^2/minute, integrated over minutes to get Grams of C/m^2

#Net CH4 Flux
df_2023 <- df_2023 %>%
  mutate(FCH4_F_no_NAs = ifelse(is.na(FCH4_F), 0, FCH4_F*60*(1/1000000)*12))

ggplot(data=df_2023)+
  geom_point(aes(x=TIMESTAMP, y=FCH4_F, colour = "red"))+
  geom_point(aes(x=TIMESTAMP, y=FCH4_F_no_NAs))

net_CH4 <- trapz(df_2023$time_minutes, df_2023$FCH4_F_no_NAs)

## Test for Sum/Integral match up 
# net_CH4_sum <- sum(df_2023$FCH4_F_no_NAs)

## change to ameriflux submission to get different value? 11/12 ish?; Resolved, Marco uses g CH4 not g C 

# Use IPCC Sixth Assessment Report (AR6) global warming potentials, 100 year time period - could use paper gwp* or 20 yr time period later? 

net_CH4_CO2e <- net_CH4*27.2
sum = net_CO2+net_CH4


#Dataframe created to generate bar graph
net_wp_2023 <- data.frame(
  Category = c("CO2", "CH4", "Total"),
  Value = c(round(net_CO2, 2), round(net_CH4, 2), round(sum, 2) 
))

#Plot here

ggplot(net_wp_2023, aes(x = Category, y = Value)) +
  theme_bw()+
  geom_bar(stat = "identity", position = "dodge", fill = "turquoise3") +
  geom_hline(yintercept=0, colour = "black")+
  labs(
    x = "",
    y = expression("Net Carbon Flux (g C"~m^-2~y^-1*")")) +
  geom_label(aes(label = Value), vjust = ifelse(net_wp_2023$Value >= 0, -0.7, 1.5), colour = "black", fill ="white")+
  scale_y_continuous(limits=c(-15, 13))

#remove warming potential



```



#### Create derivative of daily averages of FC

```{r}

dx=1
dy=diff(df_avg_2023$FC_F)

    
derivative = dy/dx


#adds one NA to make length of derivative = length of df
derivative = c(derivative, NA)

df_avg_2023$derivative = derivative


## Plots FC and derivative

ggplot(data = df_avg_2023) +
  theme_bw() +
  geom_line(aes(x = DOY, y = (FC_F*60*60*24*(1/1000000)*12)), color = 'darkblue') +
  geom_line(aes(x=DOY, y=derivative), color = 'darkgreen') +
  geom_line(aes(x = DOY, y = 0, color = 'black')) +
  scale_y_continuous(name = expression('FC (Grams of Carbon per m^2 per day'))

```

# Definition of Seasons

Uses ratio of par in/out, soil heat flux data, snow depth, air temp to identify seasonal periods

```{r}

# last period of the growing season is senescence, analyze with growing season?
# Re-adjust to determine best way to capture ecosystem functions in seasonal definitions

# Define seasons by flux: use biomet variables to explain why the flux is changing, but use flux as deinite reasoning for season changes

ggplot(data = df_avg_2023) +
  theme_bw() +
  geom_line(aes(x = DOY, y = TS_1_2_1), color = 'red') +
  geom_line(aes(x = DOY, y = TA), color = 'darkgreen') +
  geom_line(aes(x = DOY, y = (PPFD_OUT*500) / PPFD_IN), color = 'green') +
  ## Lower values = more green
  geom_line(aes(x = DOY, y = D_SNOW/2), color = 'purple') +
  geom_line(aes(x = DOY, y = (FC_F*15)), color = 'darkblue') +
  geom_line(aes(x = DOY, y = 0, color = 'black')) +
  scale_y_continuous(name = expression('Biomet Vars & FC'), limits = c(-30,20)) +
  geom_vline(xintercept = 130)+ #end of winter
  geom_vline(xintercept = 150)+ #end of snowmelt
  geom_vline(xintercept = 230)+ #end of growing season
  geom_vline(xintercept = 325)+ #end of Fall Senescence
  scale_x_continuous(limits = c(0, 366))

## Just CO2 Plot: for defining seasons by flux patterns

ggplot(data = df_avg_2023) +
  theme_bw()+
  geom_point(aes(x = DOY, y = (FC_F*60*60*24*(1/1000000)*12)), color = 'darkgreen') +
  geom_line(aes(x = DOY, y = 0, color = 'darkblue')) +
  scale_y_continuous(name = expression('FC (Grams of Carbon per m^2 per day'), limits = c(-5,5)) +
  geom_vline(xintercept = 130)+ #end of winter
  geom_vline(xintercept = 150)+ #end of snowmelt
  geom_vline(xintercept = 230)+ #end of growing season
  geom_vline(xintercept = 325)+ #end of Fall Senescence
  scale_x_continuous(limits = c(0, 366))
```

#### Add Seasons to Dataframes

``` {r}

# Definition of seasons in the daily average dataframe 

df_avg_2023 <- df_avg_2023 %>%
  mutate(
      season = case_when(
      (DOY >= 249 & DOY <= 294) ~ 'Fall Senescence',
      (DOY >= 125 & DOY <= 162) ~ 'Snow Melt',
      (DOY >= 163 & DOY <= 248) ~ 'Growing Season',
      (DOY >= 295 | DOY <= 124) ~ 'Winter',
      TRUE ~ NA_character_
    )
  )


# Definition of seasons in the half-hourly dataframe 

df_2023 <- df_2023 %>%
  mutate(
      season = case_when(
      (DOY >= 249 & DOY <= 294) ~ 'Fall Senescence',
      (DOY >= 125 & DOY <= 162) ~ 'Snow Melt',
      (DOY >= 163 & DOY <= 248) ~ 'Growing Season',
      (DOY >= 295 | DOY <= 124) ~ 'Winter',
      TRUE ~ NA_character_
    )
  )

```


####[Plot 5] Simplified Version for poster


Definition of seasons: 3+ days of the sign of FC_F changing??

```{r}

df_avg_2023$day <- as.POSIXct(df_avg_2023$day)

## Plot with legend- use only for legend
ggplot(data = df_avg_2023) +
  theme_bw() +
  geom_hline(yintercept=0, colour = "black")+
  geom_line(aes(x = day, y = TS_1_05_1/15, colour = "5cm Soil Temperature")) +
  geom_line(aes(x = day, y = TA/15, colour = "Air Temperature")) +
  geom_point(aes(x = day, y = FC_F*60*60*24*(1/1000000)*12, colour = "NEE"))+
  scale_y_continuous(
  name = expression("NEE (g C"~m^-2~d^-1~")"),
  sec.axis = sec_axis(~ . * 15, name = expression("Temperature ("*degree*"C)"))) +
  scale_color_manual(
    name = "",
    values = c("5cm Soil Temperature" = "darkblue", "Air Temperature" = "salmon", "NEE" = "turquoise3"))+
  geom_vline(xintercept = as.POSIXct("2023-05-05"))+ #end of winter, DOY 125
  geom_vline(xintercept =  as.POSIXct("2023-06-12"))+ #end of snowmelt, DOY 163
  geom_vline(xintercept =  as.POSIXct("2023-09-06"))+ #end of growing season, DOY 249
  geom_vline(xintercept =  as.POSIXct("2023-10-22"))
  
  #end of Fall Senescence, DOY 295



# Plot without legend, has better scale
ggplot(data = df_avg_2023) +
  theme_bw() +
  geom_hline(yintercept=0, colour = "black")+
  geom_line(aes(x = day, y = TS_1_05_1/15), colour = "darkblue") +
  geom_line(aes(x = day, y = TA/15), colour = "salmon") +
  geom_point(aes(x = day, y = FC_F*60*60*24*(1/1000000)*12), colour = "turquoise3")+
  scale_y_continuous(name = expression("NEE ("*g C~m^-2~d^-1*")"), sec.axis = sec_axis(~ . * 15, name = expression("Temperature ("*degree*"C)")))+
  scale_x_datetime(name="")+
  geom_vline(xintercept = as.POSIXct("2023-05-05"))+ #end of winter, DOY 125 (05/05)
  geom_vline(xintercept =  as.POSIXct("2023-06-12"))+ #end of snowmelt, DOY 163
  geom_vline(xintercept =  as.POSIXct("2023-09-06"))+ #end of growing season, DOY 249
  geom_vline(xintercept =  as.POSIXct("2023-10-22"))

  #end of Fall Senescence, DOY 295 (10-22)



```


# Seasonal Correlations

correlation between variables in growing season

```{r}

df_growing_avg_2023 <- filter(df_avg_2023, season == "Growing Season")

cor(df_growing_avg_2023$FC_F, df_growing_avg_2023$TA)


```


# Year-Long Budget Plot

Calculates the entire year's total emissions for NEE and Methane flux

#### NEE

```{r}


# For unit adjustment: 
# Units start as Micromoles of CO2/(m^2s), converted to Grams of C/m^2


# Creates column in dataframe that is in the correct units, without NAs
df_avg_2023 <- df_avg_2023 %>%
  subset(format(day, "%Y") == "2023") %>%
  mutate(day_as_POSIXct = as.POSIXct(day)) %>%
  mutate(DOY = as.numeric(format(day_as_POSIXct, "%j"))) %>%
  subset(select = -c(day_as_POSIXct)) %>%
  mutate(FC_F_no_NAs = ifelse(is.na(FC_F), 0, FC_F*60*60*24*(1/1000000)*12)) %>%
  mutate(cumulative = cumtrapz(DOY, FC_F_no_NAs))


# Calculates numeric sum of CO2 Flux in 2023
trapz(df_avg_2023$DOY, df_avg_2023$FC_F_no_NAs)
#returns -12.24842 grams of C/m2


# Plots cumulative CO2 Flux for the year of 2023
ggplot(data = df_avg_2023, aes(x=DOY, y=cumulative, color = season))+
  geom_point()+
  scale_x_continuous(lim = c(0, 365))+
  geom_hline(yintercept=0, col="black")+ 
  scale_y_continuous(expression('Cumulative CO2 Emissions (g C/m^2)'))
  

```

#### Methane

```{r}

# For unit adjustment: 
#   Units start as Nanomoles of CO2/(m^2s), converted to Grams of C/m^2

df_avg_2023 <- df_avg_2023 %>%
  subset(format(day, "%Y") == "2023") %>%
  mutate(day_as_POSIXct = as.POSIXct(day)) %>%
  mutate(DOY = as.numeric(format(day_as_POSIXct, "%j"))) %>%
  subset(select = -c(day_as_POSIXct)) %>%
  mutate(FCH4_F_no_NAs = ifelse(is.na(FCH4_F), 0, FCH4_F)) %>%
  mutate(cumulativeCH4 = 
           cumtrapz(DOY, FCH4_F_no_NAs*60*30*(1/1000000000)*1000*12))

trapz(df_avg_2023$DOY, df_avg_2023$FCH4_F*60*30*(1/1000000000)*1000*12)
#returns 0.1734819

ggplot(data = df_avg_2023, aes(x=DOY, y=cumulativeCH4, color = season))+
  geom_point()+
  scale_x_continuous(lim = c(0, 365))+
  geom_hline(yintercept=0, col="black")+ 
  scale_y_continuous(expression('Cumulative CH4 Emissions (mg of C)'))
  

```

# Seasonal Budgets

Use half-hourly data to calculate net co2 budgets by season Average rate per day, separate graph for daily rate geom_violin

## [Plot 3] NEE

Finds the net CO2 exchange of each season as defined above

```{r}

seasonal_integrals <- function(df) {
  
  # Calculate integral (sum) for each season
  integrals <- df %>%
    group_by(season) %>%
    summarise(integral_value = sum(FC_F, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(season)
  
  
  # Changes units from  Micromoles of CO2/((m^2)s) to Grams of C/m^2, and rounds
    integrals$integral_value = 
      round(integrals$integral_value*60*30*(1/1000000)*12, 2)
  
  return(integrals)
}

seasonal_integrals_2023 <- seasonal_integrals(df_2023)

#reorders seasons to timeline order
seasonal_integrals_2023$season <- factor(seasonal_integrals_2023$season, levels = c("Snow Melt", "Growing Season", "Fall Senescence", "Winter"))

ggplot(seasonal_integrals_2023, aes(x = season, y = integral_value)) +
  theme_bw()+
  geom_hline(yintercept=0, colour="black")+
  geom_bar(stat = "identity", position = "dodge", fill = "turquoise3") +
  labs(
    x = " ",
    y = expression("Net CO"[2] * " Flux (g C m"^-2*")"),
    title = expression("Net CO"[2] * " Flux by Season")
  ) +
  geom_label(aes(label = integral_value), vjust = ifelse(seasonal_integrals_2023$integral_value >= 0, -0.7, 1.5), colour = "black", fill ="white")+
  scale_y_continuous(limits=c(-53, 23))
 



# Bar graph showing growing season vs. year round analysis
# Change GPP to negative to show dynamics in budget




```

## GPP

Finds the net GPP of each season

```{r}

seasonal_integrals <- function(df) {
  
  # Calculate integral (sum) for each season
  integrals <- df %>%
    group_by(season) %>% 
    summarise(integral_value = sum(GPP_F, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(season)
  
    
  # Changes units from  Micromoles of CO2/(m^2s) to Grams of C/m^2, 
  #     makes GPP a negative value, and rounds
    integrals$integral_value = 
      round(integrals$integral_value*-60*30*(1/1000000)*12, 2)
  
  return(integrals)
}

seasonal_integrals_2023 <- seasonal_integrals(df_2023)

ggplot(seasonal_integrals_2023, aes(x = season, y = integral_value)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    x = "Season",
    y = "Net GPP (Grams of Carbon/m^2)",
    title = "2023 GPP by season"
  ) +
  theme_minimal()+
  geom_text(aes(label = integral_value), vjust = 1, colour = "orange")



# Bar graph showing growing season vs. year round analysis



```

## RECO

```{r}

seasonal_integrals <- function(df) {
  
  # Calculate integral (sum) for each season
  integrals <- df %>%
    group_by(season) %>%
    summarise(integral_value = sum(RECO, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(season)
  
    
  # Changes units from  Micromoles of CO2/(m^2s) to Grams of C/m^2, and rounds
    integrals$integral_value = 
      round(integrals$integral_value*60*30*(1/1000000)*12, 2)
  
  return(integrals)
}

seasonal_integrals_2023 <- seasonal_integrals(df_2023)

ggplot(seasonal_integrals_2023, aes(x = season, y = integral_value)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    x = "Season",
    y = "Net ER (Grams of Carbon/m^2)",
    title = "2023 Ecosystem Respiration by season"
  ) +
  theme_minimal()+
  geom_text(aes(label = integral_value), vjust = 1, colour = "orange")



# Bar graph showing growing season vs. year round analysis



```

## [Plot 4] Methane

Conversion not giving meaningful numbers, changed to milligrams

```{r}

seasonal_integrals <- function(df) {
  
  # Calculate integral (sum) for each season
  integrals <- df %>%
    group_by(season) %>%
    summarise(integral_value = sum(FCH4_F, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(season)
  
    
  # Changes units from mmol of CH4/(m^2s) to grams of C/m^2, and rounds
    integrals$integral_value = 
      round(integrals$integral_value*60*30*(1/1000000)*12, 2)
  
  return(integrals)
}

seasonal_integrals_2023 <- seasonal_integrals(df_2023)

#reorders seasons to timeline order
seasonal_integrals_2023$season <- factor(seasonal_integrals_2023$season, levels = c("Snow Melt", "Growing Season", "Fall Senescence", "Winter"))

ggplot(seasonal_integrals_2023, aes(x = season, y = integral_value)) +
  theme_bw()+
  geom_hline(yintercept=0, colour="black")+
  geom_bar(stat = "identity", position = "dodge", fill = "turquoise3") +
  labs(
    x = "",
    y = expression("Net CH"[4] * " Flux (g C m"^-2*")"),
    title = expression("Net CH"[4] * " Flux by Season")
  ) +
  geom_label(aes(label = integral_value), vjust = ifelse(seasonal_integrals_2023$integral_value >= 0, -0.7, 1.5), colour = "black", fill ="white")+
  scale_y_continuous(limits=c(0, 6.1))

```


# Snowmelt peak analysis

```{r}

## Shows non-temperature correlated peak in CO2 Flux data during snowmelt


## May 15: DOY 135

ggplot(data = df_2023) +
  theme_bw() +
  geom_point(aes(x = TIMESTAMP, y = FC), color = 'black') +
  # geom_point(aes(x = TIMESTAMP, y = FC_night), color = 'deeppink2') +
  geom_point(aes(x = TIMESTAMP, y = GPP_F), color = 'green') +
  geom_point(aes(x = TIMESTAMP, y = FCH4_F*7), color = 'orange') +
  # geom_point(aes(x = TIMESTAMP, y = RECO), color = 'purple') +
  geom_line(aes(x = TIMESTAMP, y = TS_2_05_1), color = 'blue') + 
  geom_line(aes(x= TIMESTAMP, y= TA*(1/20)), color="purple")+
  geom_point(aes(x=TIMESTAMP, y = G_1_1_1*(1/50)), color = "grey")+
  geom_hline(yintercept = 0) +
  scale_y_continuous(
    name = expression('CO2 Data'),
    limits = c(-7, 5),
    sec.axis = sec_axis(~./4, name = "5cm Soil Temp")
    ) +
  scale_x_datetime(limits = as.POSIXct(c('2023-05-05', '2023-05-30')))+
  scale_y_continuous(limits = c(-2.5, 5))

```


#  [Plots 6/7] Temperature Relationship

Uses non-gap filled data for NEE, nighttime CO2 data Uses gap filled data for GPP and RECO

All use half-hourly data

```{r}

#Creates a month variable in the 2023 dataframe

df_2023$month = as.numeric(as.yearmon(df_2023$day))

#Plots flux variables vs. 5cm soil temp to visualize temperature/co2 flux relationship

#Not that useful- temp used to partition data
ggplot(data=df_2023)+
  geom_point(aes(x=TS_1_05_1, y=RECO, col = day))+
  labs(
    x = "Soil Temp",
    y = "Respiration",
    title = "Respiraton vs. Soil Temp"
  )

# FC_night used to estimate RECO without temp correlation or gap filling

ggplot(data=df_2023)+
  theme_bw()+
  geom_hline(yintercept = 0)+
  geom_vline(xintercept = 0)+
  geom_point(aes(x=TS_1_05_1, y=FC_night, col = DOY))+
scale_color_gradient(low = "navy", high = "salmon")+
  labs(
    x = expression("5cm Soil Temperature ("*degree*"C)"),
    y = expression("Half-hourly nighttime CO"[2] * " Flux ("*mu*mol~m^-2~s^-1*")"),
    title = expression("Nighttime CO"[2] * " Flux vs. Soil Temperature")
  )+
  scale_x_continuous(limits=c(-15,25))+
  scale_y_continuous(limits=c(-0.5,2.5))

#use this plot for poster 


ggplot(data=df_2023)+
  geom_vline(xintercept=0)+
  theme_bw()+
  geom_point(aes(x=TS_1_05_1, y=FCH4*(1/1000), col = DOY))+
scale_color_gradient(low = "navy", high = "salmon")+
  labs(
    x = expression("5cm Soil Temperature ("*degree*"C)"),
    y = expression("Half-hourly CH"[4] * " Flux ("*mu*mol~m^-2~s^-1*")"),
    title = expression("CH"[4] * " Flux vs. Soil Temperature")
  )+
  scale_x_continuous(limits = c(-15, 30))+
  scale_y_continuous(limits = c(-0.04, .150))

```



#### Exponential - doesn't work yet

```{r}


  exp_model <- nls(
    formula = as.formula(paste(df_2023$FC_night, "~ a * exp(b *", df_2023$TS_1_05_1, ")")),
    data = df_2023,
    start = list(a = 1, b = 0.1)  # Starting values for the coefficients
  )
  
  # Extract coefficients
  coef_values <- coef(exp_model)
  
  # Create a new column for fitted values
  data$fit <- coef_values["a"] * exp(coef_values["b"] * data[[x_var]])
  
  
  ggplot(data=data)+
  theme_bw()+
  geom_hline(yintercept = 0)+
  geom_vline(xintercept = 0)+
  geom_line(aes_string(y = fit), x=x_var, color = "black") +
  geom_point(aes(x=x_var, y=y_var, col = DOY))+
scale_color_gradient(low = "navy", high = "salmon")

  
}

exponential_fit_plot(df_2023, "TS_1_05_1", "FC_night")




ggplot(data=df_2023)+
  theme_bw()+
  geom_hline(yintercept = 0)+
  geom_vline(xintercept = 0)+
  geom_line(aes_string(y = fit), x=TS_1_05_1, color = "black") +
  geom_point(aes(x=TS_1_05_1, y=FC_night, col = DOY))+
scale_color_gradient(low = "navy", high = "salmon")+
  labs(
    x = expression("5cm Soil Temperature ("*degree*"C)"),
    y = expression("Half-hourly Nighttime CO"[2] * " Flux"),
    title = expression("Nighttime CO"[2] * " Flux vs. Soil Temperature")
  )+
  scale_x_continuous(limits=c(-15,18))+
  scale_y_continuous(limits=c(-0.5,4))

```